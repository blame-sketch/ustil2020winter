#include<stdio.h>
#include <stdlib.h>

typedef struct node
{
	char data = '@';
	struct node* left;
	struct node* right;
}BTnode;

BTnode* CreateTree(BTnode* root, int x)
{
	if (!root)
	{
		root = (BTnode*)malloc(sizeof(BTnode));
		root->data = x;
		root->left = root->right = NULL;
	}
	else
	{
		if (root->data > x)
			root->right = CreateTree(root->right, x);
		else
			root->left = CreateTree(root->left, x);
	}
	return root;
}
//前序遍历
void Forder(BTnode* root) {
    if (root) {
        printf("%d ", root->data);
        Forder(root->left);
        Forder(root->right);
    }
}
//中序遍历
void Inorder(BTnode* root) {
    if (root) {
        Inorder(root->left);
        printf("%d ", root->data);
        Inorder(root->right);
    }
}
//后续遍历
void Porder(BTnode* root) {
    if (root) {
        Porder(root->left);
        Porder(root->right);
        printf("%d ", root->data);
    }
}

//主函数
int main(void) {
	BTnode* root = NULL;
	int x;//当前值
	int n;//数据的个数
	int i;//循环变量
	printf("请输入n=");
	scanf_s("%d", &n);
	printf("请输入二叉树的结点data\n");
	for (i = 0; i < n; i++)
	{
		scanf_s("%d", &x);
		root = CreateTree(root, x);
	}

	printf("\n前序遍历为:");
	Forder(root);
	printf("\n中序遍历为:");
	Inorder(root);
	printf("\n后序遍历为:");
	Porder(root);
	printf("\n");
}
typedef struct
{
	node* bottom;
	node* top;
}Stack;

//初始化栈
void init(Stack* s)
{
	s->bottom = (node*)malloc(100 * sizeof(node));
	s->top = s->bottom;
}

int ifEmpty(Stack s)//判断是否为空
{
	if (s.top = s.bottom)
		return 1;
	else
		return 0;
}


void push(Stack* s, node node)
{
	*(s->top++) = node;
}

//出栈函数
node pop(Stack* s)
{
	node node;
	node = *(--(s->top));

	return node;
}
//看栈顶函数
node Checkstack(Stack* s)
{
	return  *(s->top - 1);//返回栈顶元素
}

int i = -1;
node* createTree(char* b)//创建二叉树
{
	node* p;

	if (b[++i] == 0)
	{
		p = NULL;
	}
	else
	{
		p = (node*)malloc(sizeof(node));
		p->data = b[i];
		p->left = createTree(b);
		p->right = createTree(b);

	}
	return p;
}
//先序遍历
void  Forder1(node* root)
{
	Stack po;
	node curr = *root;
	init(&po);
	while (curr.data != 0 || !ifEmpty(po))
	{
		if (curr.data == 0)
		{
			curr = pop(&po);

		}
		if (curr.right != NULL)
		{
			push(&po, *curr.right);                                       //将右子进栈
		}
		printf("%c", curr.data);
		if (curr.left != NULL)
			curr = *curr.left;
		else
			curr = pop(&po);
		if ((curr.left == NULL) && (curr.right == NULL))
		{
			printf("%c", curr.data);
			curr.data = 0;
		}

	}
}
//中序遍历
void Inorder1(node* root)
{
	Stack ms;
	node curr = *root;
	int flag = 0;
	init(&ms);
	while (curr.data != 0 || ifEmpty(ms))
	{
		if (curr.left != NULL && flag == 0)
		{
			push(&ms, curr);
			curr = *curr.left;
		}
		else
		{
			printf("%d ", curr.data);
			if (curr.right != NULL)
				curr = *curr.right;
			flag = 0;
		}
		if (curr.right == NULL && curr.left == NULL)
		{
			printf("%d ", curr.data);
			if (ifEmpty(ms) == 1) 
				break;
			curr = pop(&ms);
			flag = 1;
		}
	}
}

int main1()
{
	char a[] = { 1,2,3,4,5,6,7,8,9 };
	char* tree = a;
	node* root = createTree(tree);
	printf("用非递归方式前序遍历二叉树\n");
	Forder1(root);
	printf("用非递归方式中序遍历二叉树\n");
	Inorder1(root);
	return 0;

}

